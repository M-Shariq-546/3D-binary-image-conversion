# -*- coding: utf-8 -*-
"""Project 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19n8XM0yEUWTeYg_39WH9Ls8chts2Tfq1

# **3D Image Extraction From Multiple Aerial Images**

**Dataset used in this Code is of Buildings and lands**

You can use any dataset of images which you want to use
"""

!pip install patchify

import os
import cv2
from PIL import Image
import numpy as np
from patchify import patchify
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from matplotlib import pyplot as plt
import random

minmaxscaler = MinMaxScaler()

!ls -lah '/content/drive/MyDrive/Semantic segmentation dataset/'

dataset_root_folder = '/content/drive/MyDrive/'

dataset_name = 'Semantic segmentation dataset'

for path, subdirs, files in os.walk(os.path.join(dataset_root_folder, dataset_name)):
  dir_name = path.split(os.path.sep)[-1]
  #print(dir_name)
  if dir_name == 'masks': # 'images
    images = os.listdir(path)
    print(path)
    #print(images)
    for i, image_name in enumerate(images):
      if (image_name.endswith('.png')): # '.jpg
        #print(image_name)
        a = True

image_patch_size = 256

image = cv2.imread(f'{dataset_root_folder}/{dataset_name}/Tile 2/images/image_part_001.jpg',1)

image.shape

image_patches = patchify(image, (image_patch_size, image_patch_size, 3), step=image_patch_size)

len(image_patches)

print("Shape of image patches would be ",  image_patches.shape)

image_x = image_patches[0,0,:,:]
#MinMaxScaler for fit transforming of the image
image_y = minmaxscaler.fit_transform(image_x.reshape(-1, image_x.shape[-1])).reshape(image_x.shape)

image_y[0].shape

#This is exactly equals to poweline GSD = (pixel pitch) * (flying height)//(focal lenght)
(image.shape[0]//image_patch_size)*image_patch_size

image_dataset = []
mask_dataset = []

for image_type in ['images' , 'masks']:
  if image_type == 'images':
    image_extension = 'jpg'
  elif image_type == 'masks':
     image_extension = 'png'
  for tile_id in range(1,8):
    for image_id in range(1,20):
      image = cv2.imread(f'{dataset_root_folder}/{dataset_name}/Tile {tile_id}/{image_type}/image_part_00{image_id}.{image_extension}',1)
      if image is not None:
        if image_type == 'masks':
          image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        size_x = (image.shape[1]//image_patch_size)*image_patch_size
        size_y = (image.shape[0]//image_patch_size)*image_patch_size
        image = Image.fromarray(image)
        image = image.crop((0,0, size_x, size_y))
        image = np.array(image)
        patched_images = patchify(image, (image_patch_size, image_patch_size, 3), step=image_patch_size)
        for i in range(patched_images.shape[0]):
          for j in range(patched_images.shape[1]):
            if image_type == 'images':
              individual_patched_image = patched_images[i,j,:,:]
              individual_patched_image = minmaxscaler.fit_transform(individual_patched_image.reshape(-1, individual_patched_image.shape[-1])).reshape(individual_patched_image.shape)
              individual_patched_image = individual_patched_image[0]
              image_dataset.append(individual_patched_image)
            elif image_type == 'masks':
              individual_patched_mask = patched_images[i,j,:,:]
              individual_patched_mask = individual_patched_mask[0]
              mask_dataset.append(individual_patched_mask)

print("Image Dataset Counts : ",len(image_dataset))
print("Masks images Dataset Counts : ",len(mask_dataset))

random_image_id = random.randint(0, len(image_dataset))

plt.figure(figsize=(14,8))
plt.subplot(121)
plt.imshow(image_dataset[random_image_id])
plt.subplot(122)
plt.imshow(mask_dataset[random_image_id])

import random
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Sample data for the 3D line graph
num_points = 50
x = np.linspace(0, 10, num_points)
y = np.sin(x)
z = np.cos(x)

# Creating a image ID
#random_image_id = random.randint(0, len(image_dataset))

# Creating a 3D figure for the line graph
fig = plt.figure(figsize=(14, 8))
ax = fig.add_subplot(121, projection='3d')

# Plot the 3D line
ax.plot(x, y, z)

# Display the image from your dataset
plt.subplot(122)
plt.imshow(image_dataset[random_image_id])

plt.show()

import random
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

#data for the 3D line graph
num_lines = 3  # Number of mini lines
num_points = 20
x = np.linspace(0, 10, num_points)
z = np.cos(x)

# Create a 3D figure for the line graph
fig = plt.figure(figsize=(14, 8))
ax = fig.add_subplot(121, projection='3d')

# Create and plot multiple mini lines with different colors
for i in range(num_lines):
    y = np.sin(x + i * np.pi / num_lines)  # Adjust the phase for different colors
    color = plt.cm.viridis(i / num_lines)  # Use a colormap to get different colors
    ax.plot(x, y, z, color=color, label=f'Line {i + 1}')

# Display legend for the mini lines
ax.legend()

# Display the random image from your dataset
plt.subplot(122)
plt.imshow(image_dataset[random_image_id])

plt.show()

mask_dataset = np.array(mask_dataset)
mask_dataset.shape[0]

label = individual_patched_mask

class_building = '#3C1098'
class_building = class_building.lstrip('#')
class_building = np.array(tuple(int(class_building[i:i+2], 16) for i in (0,2,4)))
print(class_building)

class_land = '#8429F6'
class_land = class_land.lstrip('#')
class_land = np.array(tuple(int(class_land[i:i+2], 16) for i in (0,2,4)))
print(class_land)

class_road = '#6EC1E4'
class_road = class_road.lstrip('#')
class_road = np.array(tuple(int(class_road[i:i+2], 16) for i in (0,2,4)))
print(class_road)

class_vegetation = '#FEDD3A'
class_vegetation = class_vegetation.lstrip('#')
class_vegetation = np.array(tuple(int(class_vegetation[i:i+2], 16) for i in (0,2,4)))
print(class_vegetation)

class_water = '#E2A929'
class_water = class_water.lstrip('#')
class_water = np.array(tuple(int(class_water[i:i+2], 16) for i in (0,2,4)))
print(class_water)

class_unlabeled = '#9B9B9B'
class_unlabeled = class_unlabeled.lstrip('#')
class_unlabeled = np.array(tuple(int(class_unlabeled[i:i+2], 16) for i in (0,2,4)))
print(class_unlabeled)

def rgb_to_label(label):
  label_segment = np.zeros(label.shape, dtype=np.uint8)
  label_segment[np.all(label == class_water, axis=-1)] = 0
  label_segment[np.all(label == class_land, axis=-1)] = 1
  label_segment[np.all(label == class_road, axis=-1)] = 2
  label_segment[np.all(label == class_building, axis=-1)] = 3
  label_segment[np.all(label == class_vegetation, axis=-1)] = 4
  label_segment[np.all(label == class_unlabeled, axis=-1)] = 5
  #print(label_segment)
  label_segment = label_segment[:,:,0]
  #print(label_segment)
  return label_segment

labels = []
for i in range(mask_dataset.shape[0]):
  label = rgb_to_label(mask_dataset[i])
  labels.append(label)

np.unique(labels)

print("Total unique labels based on masks: ",format(np.unique(labels)))

total_classes = len(np.unique(labels))
print("Total Classes Found in classes.json file : ",total_classes)

from tensorflow.keras.utils import to_categorical
labels_categorical_dataset = to_categorical(labels, num_classes=total_classes)

labels_categorical_dataset.shape

master_trianing_dataset = image_dataset

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(master_trianing_dataset, labels_categorical_dataset, test_size=0.15, random_state=100)

"""**The End**"""